{"version":3,"sources":["webpack:///chapter_04/treasure-hunter/main.js","webpack:///webpack/bootstrap 32dd76c64819d070ad88","webpack:///./src/chapter_04/treasure-hunter.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","6","setup","id","Resources","textures","gameScene","Container","stage","addChild","dungeon","Sprite","door","position","set","explorer","x","y","height","vx","vy","treasure","width","direction","blob","randomInt","blobSpeed","blobs","push","healthBar","initHealthBar","gameOverScene","visible","message","Text","font","bindKeyBorad","state","play","gameLoop","requestAnimationFrame","renderer","render","area","bump","contain","explorerHit","forEach","blobHitsWall","has","hitTestRectangle","alpha","outer","end","text","innerBar","Graphics","beginFill","drawRect","endFill","outerBar","left","keyboard","right","up","down","press","explorerSpeed","release","isDown","min","max","Math","floor","random","PIXI","Loader","loader","Renderer","Rectangle","autoDetectRenderer","resources","utils","TextureCache","Texture","Bump","view","style","border","backgroundColor","document","getElementById","appendChild","source","fontFamily","split","pop","newStyle","createElement","fontFace","createTextNode","head","add","load"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,KDMMC,EACA,SAAUvB,EAAQD,GEVxB,QAASyB,KAEPC,GAAKC,EAAU,8BAA8BC,SAI7CC,EAAY,GAAIC,GAChBC,EAAMC,SAASH,EAIf,IAAII,GAAU,GAAIC,GAAOR,GAAG,eAC5BG,GAAUG,SAASC,GAGnBE,EAAO,GAAID,GAAOR,GAAG,aACrBS,EAAKC,SAASC,IAAI,GAAI,GACtBR,EAAUG,SAASG,GAGnBG,EAAW,GAAIJ,GAAOR,GAAG,iBACzBY,EAASC,EAAI,GACbD,EAASE,GAAKX,EAAUY,OAASH,EAASG,QAAU,EACpDH,EAASI,GAAK,EACdJ,EAASK,GAAK,EACdd,EAAUG,SAASM,GAGnBM,EAAW,GAAIV,GAAOR,GAAG,iBACzBkB,EAASL,EAAIV,EAAUgB,MAAQD,EAASH,OAAS,GACjDG,EAASJ,GAAKX,EAAUY,OAASG,EAASH,QAAU,EACpDZ,EAAUG,SAASY,EASnB,KAAK,GAHDE,GAAY,EAGP5C,EAAI,EAAGA,EANI,EAMeA,IAAK,CAEtC,GAAI6C,GAAO,GAAIb,GAAOR,GAAG,aAKrBa,EAZQ,GAYMrC,EAXN,IAcRsC,EAAIQ,EAAU,EAAGjB,EAAMU,OAASM,EAAKN,OAGzCM,GAAKR,EAAIA,EACTQ,EAAKP,EAAIA,EAKTO,EAAKJ,GAAKM,EAAYH,EAGtBA,IAAc,EAGdI,EAAMC,KAAKJ,GAEXlB,EAAUG,SAASe,GAGrBK,EAAYC,IACZD,EAAUhB,SAASC,IAAIN,EAAMc,MAAQ,IAAK,GAC1ChB,EAAUG,SAASoB,GAGnBE,EAAgB,GAAIxB,GACpBC,EAAMC,SAASsB,GAEfA,EAAcC,SAAU,EAGxBC,EAAU,GAAIC,GAAK,YAAcC,KAAM,mBACvCF,EAAQjB,GAAKR,EAAMc,MAAQW,EAAQX,OAAS,EAC5CW,EAAQhB,EAAIT,EAAMU,OAAS,EAAI,GAC/Ba,EAActB,SAASwB,GAGvBG,IAGAC,EAAQC,EAGRC,IAIF,QAASA,KAEPC,sBAAsBD,GAGtBF,IAGAI,EAASC,OAAOlC,GAIlB,QAAS8B,KAGP,GAAIK,IAAS3B,EAAG,GAAIC,EAAG,GAAIK,MAAO,IAAKJ,OAAQ,IAG/CH,GAASC,GAAKD,EAASI,GACvBJ,EAASE,GAAKF,EAASK,GAGvBwB,EAAKC,QAAQ9B,EAAU4B,EAGvB,IAAIG,IAAc,CAGlBnB,GAAMoB,QAAQ,SAAAvB,GAEZA,EAAKP,GAAKO,EAAKJ,EAGf,IAAI4B,GAAeJ,EAAKC,QAAQrB,EAAMmB,EAIlCK,KACEA,EAAaC,IAAI,QAAUD,EAAaC,IAAI,aAC9CzB,EAAKJ,KAAO,GAMZwB,EAAKM,iBAAiBnC,EAAUS,KAClCsB,GAAc,KAKdA,GAEF/B,EAASoC,MAAQ,GAGjBtB,EAAUuB,MAAM9B,OAAS,GAIzBP,EAASoC,MAAQ,EAKfP,EAAKM,iBAAiBnC,EAAUM,KAElCA,EAASL,EAAID,EAASC,EAAI,EAC1BK,EAASJ,EAAIF,EAASE,EAAI,GAKxBY,EAAUuB,MAAM9B,OAAS,IAC3Be,EAAQgB,EACRpB,EAAQqB,KAAO,aAKbV,EAAKM,iBAAiB7B,EAAUT,KAClCyB,EAAQgB,EACRpB,EAAQqB,KAAO,YAKnB,QAASD,KACP/C,EAAU0B,SAAU,EACpBD,EAAcC,SAAU,EAG1B,QAASF,KAEP,GAAID,GAAY,GAAItB,GAGhBgD,EAAW,GAAIC,EACnBD,GAASE,UAAU,GACnBF,EAASG,SAAS,EAAG,EAAG,IAAK,GAC7BH,EAASI,UACT9B,EAAUpB,SAAS8C,EAGnB,IAAIK,GAAW,GAAIJ,EAQnB,OAPAI,GAASH,UAAU,UACnBG,EAASF,SAAS,EAAG,EAAG,IAAK,GAC7BE,EAASD,UACT9B,EAAUpB,SAASmD,GAEnB/B,EAAUuB,MAAQQ,EAEX/B,EAIT,QAASO,KAEP,GAAIyB,GAAOC,SAAS,IAChBC,EAAQD,SAAS,IACjBE,EAAKF,SAAS,IACdG,EAAOH,SAAS,GAGpBD,GAAKK,MAAQ,WAEXnD,EAASI,IAAMgD,EACfpD,EAASK,GAAK,GAIhByC,EAAKO,QAAU,WAIRL,EAAMM,QAA0B,IAAhBtD,EAASK,KAC5BL,EAASI,GAAK,IAKlB4C,EAAMG,MAAQ,WACZnD,EAASI,GAAKgD,EACdpD,EAASK,GAAK,GAGhB2C,EAAMK,QAAU,WACTP,EAAKQ,QAA0B,IAAhBtD,EAASK,KAC3BL,EAASI,GAAK,IAKlB6C,EAAGE,MAAQ,WACTnD,EAASK,IAAM+C,EACfpD,EAASI,GAAK,GAGhB6C,EAAGI,QAAU,WACNH,EAAKI,QAA0B,IAAhBtD,EAASI,KAC3BJ,EAASK,GAAK,IAKlB6C,EAAKC,MAAQ,WACXnD,EAASK,GAAK+C,EACdpD,EAASI,GAAK,GAGhB8C,EAAKG,QAAU,WACRJ,EAAGK,QAA0B,IAAhBtD,EAASI,KACzBJ,EAASK,GAAK,IAQpB,QAASK,GAAU6C,EAAKC,GACtB,MAAOC,MAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,IAAMA,EAxUvD,GAAM/D,GAAYoE,KAAKpE,UACjBiD,EAAWmB,KAAKnB,SAChBoB,EAASD,KAAKE,OAEdC,GADYH,KAAKI,UACNJ,KAAKK,oBAChB5E,EAAYuE,KAAKE,OAAOI,UACxBtE,EAASgE,KAAKhE,OACduB,EAAOyC,KAAKzC,KAKZU,GAJe+B,KAAKO,MAAMC,aAChBR,KAAKS,QAGR,GAAIC,MAAKV,OAGhBlC,EAAWqC,EAAS,IAAK,IAE/BrC,GAAS6C,KAAKC,MAAMC,OAAS,iBAC7B/C,EAASgD,gBAAkB,WAG3BC,SAASC,eAAe,QAAQC,YAAYnD,EAAS6C,KAGrD,IAAM9E,GAAQ,GAAID,GAEdD,EAAY,KACZyB,EAAgB,KAGhBM,EAAQC,EACRvB,EAAW,KACXoD,EAAgB,EAEhBxC,KACAD,EAAY,EACZL,EAAW,KACXT,EAAO,KACPiB,EAAY,KACZI,EAAU,MAqSd,SAAkB4D,GAIhB,GAAIC,GAAaD,EAAOE,MAAM,KAAKC,MAAMD,MAAM,KAAK,GAGhDE,EAAWP,SAASQ,cAAc,SAClCC,qCACcL,EADd,qBAEUD,EAFV,UAIJI,GAASL,YAAYF,SAASU,eAAeD,IAC7CT,SAASW,KAAKT,YAAYK,IAhTnB,wBAGTrB,EAAO0B,KACL,6BACA,yBACCC,KAAKrG","file":"chapter_04/treasure-hunter/main.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 6:\n/***/ (function(module, exports) {\n\n/**\n * @fileoverview Treasure Hunter\n * @author burning <iburning@live.cn>\n * @version 2017.08.28\n */\n\n//Aliases\n// console.log('PIXI', PIXI)\nvar Container = PIXI.Container;\nvar Graphics = PIXI.Graphics;\nvar Loader = PIXI.loader;\nvar Rectangle = PIXI.Rectangle;\nvar Renderer = PIXI.autoDetectRenderer;\nvar Resources = PIXI.loader.resources;\nvar Sprite = PIXI.Sprite;\nvar Text = PIXI.Text;\nvar TextureCache = PIXI.utils.TextureCache;\nvar Texture = PIXI.Texture;\n\n// Create a new instance of the Bump collision library\nvar bump = new Bump(PIXI);\n\n// Create a Pixi renderer\nvar renderer = Renderer(512, 512);\n// Set the canvas's border style and background color\nrenderer.view.style.border = \"1px solid #000\";\nrenderer.backgroundColor = \"0xFFFFFF\";\n\n// Add the canvas to the HTML document\ndocument.getElementById(\"pixi\").appendChild(renderer.view);\n\n// Create a container object called the 'stage'\nvar stage = new Container();\n\nvar gameScene = null;\nvar gameOverScene = null;\n\n// Set the initial game state\nvar state = play;\nvar explorer = null;\nvar explorerSpeed = 3;\n// An array to store all the blob monsters\nvar blobs = [];\nvar blobSpeed = 5;\nvar treasure = null;\nvar door = null;\nvar healthBar = null;\nvar message = null;\n\nlinkFont(\"assets/Pixilator.ttf\");\n\n// Load resources (images and fonts) and run the 'setup' function when it's done\nLoader.add([\"assets/treasureHunter.json\", \"assets/Pixilator.ttf\"]).load(setup);\n\nfunction setup() {\n  // Create an 'id' alias for the texture atlas frame ids\n  id = Resources[\"assets/treasureHunter.json\"].textures;\n  // console.log('id', id)\n\n  // The 'gameScene' container that contains all the main game sprites\n  gameScene = new Container();\n  stage.addChild(gameScene);\n\n  // Create the main sprites:\n  // The 'dungeon' sprite\n  var dungeon = new Sprite(id['dungeon.png']);\n  gameScene.addChild(dungeon);\n\n  // The 'door' sprite\n  door = new Sprite(id['door.png']);\n  door.position.set(32, 0);\n  gameScene.addChild(door);\n\n  // The 'explorer' sprite\n  explorer = new Sprite(id['explorer.png']);\n  explorer.x = 64;\n  explorer.y = (gameScene.height - explorer.height) / 2;\n  explorer.vx = 0;\n  explorer.vy = 0;\n  gameScene.addChild(explorer);\n\n  // The 'treasure' sprite\n  treasure = new Sprite(id['treasure.png']);\n  treasure.x = gameScene.width - treasure.height - 48;\n  treasure.y = (gameScene.height - treasure.height) / 2;\n  gameScene.addChild(treasure);\n\n  // The 'blobs' enemy sprites\n  var numberOfBlobs = 6;\n  var spacing = 48;\n  var xOffset = 150;\n  var direction = 1;\n\n  // Make as many blobs as there are 'numberOfBlobs'\n  for (var i = 0; i < numberOfBlobs; i++) {\n    // Make a blob\n    var blob = new Sprite(id[\"blob.png\"]);\n\n    // Space each blob horizontally according to the 'spacing' value.\n    // 'xOffset' determines the point from the left of the screen\n    // at which the first blob should be added\n    var x = spacing * i + xOffset;\n\n    // Give the blob a random y position\n    var y = randomInt(0, stage.height - blob.height);\n\n    // Set the blob's position\n    blob.x = x;\n    blob.y = y;\n\n    // Set the blob's vertical velocity. 'direction' will be either '1' or '-1'.\n    // '1' means enemy will move down and '-1' means the blob will move up.\n    // Multiplying 'direction' by 'speed' determines the blob's vertical direction\n    blob.vy = blobSpeed * direction;\n\n    // Reverse the direction for the next blob\n    direction *= -1;\n\n    // Push the blob into the 'blobs' array\n    blobs.push(blob);\n    // Add the blob to the 'gameScene'\n    gameScene.addChild(blob);\n  }\n\n  healthBar = initHealthBar();\n  healthBar.position.set(stage.width - 170, 4);\n  gameScene.addChild(healthBar);\n\n  // Create the 'gameOver' scene\n  gameOverScene = new Container();\n  stage.addChild(gameOverScene);\n  // Make the 'gameOver' scene invisible when the game first starts\n  gameOverScene.visible = false;\n\n  // Create the text sprite and add it to the 'gameOver' scene\n  message = new Text(\"The End!\", { font: \"48px Pixilator\" });\n  message.x = (stage.width - message.width) / 2;\n  message.y = stage.height / 2 - 32;\n  gameOverScene.addChild(message);\n\n  // Bind keyboard\n  bindKeyBorad();\n\n  // Set the game's current state to 'play'\n  state = play;\n\n  // Start the game loop\n  gameLoop();\n}\n\nfunction gameLoop() {\n  // Loop this function 60 times per second\n  requestAnimationFrame(gameLoop);\n\n  // Run the current state\n  state();\n\n  // Render the stage\n  renderer.render(stage);\n}\n\nfunction play() {\n  // All the game logic goes here\n\n  var area = { x: 28, y: 10, width: 488, height: 480\n\n    // Use the explorer's velocity to make it move\n  };explorer.x += explorer.vx;\n  explorer.y += explorer.vy;\n\n  // Contain the explorer inside the area of the dungeon\n  bump.contain(explorer, area);\n\n  // Set 'explorerHit' to 'false' before checking for a collision\n  var explorerHit = false;\n\n  // Loop through all the sprites in the 'enemies' array\n  blobs.forEach(function (blob) {\n    // Move the blob\n    blob.y += blob.vy;\n\n    // Check the blob's screen boundaries\n    var blobHitsWall = bump.contain(blob, area);\n\n    // If the blob hits the top or bottom of the stage,\n    // reverse its direction\n    if (blobHitsWall) {\n      if (blobHitsWall.has(\"top\") || blobHitsWall.has(\"bottom\")) {\n        blob.vy *= -1;\n      }\n    }\n\n    // Test for a collision. If any of the enemies are touching the explorer,\n    // set 'explorerHit' to 'true'\n    if (bump.hitTestRectangle(explorer, blob)) {\n      explorerHit = true;\n    }\n  });\n\n  // If the explorer is hit...\n  if (explorerHit) {\n    // Make the explorer semi-transparent\n    explorer.alpha = 0.5;\n\n    // Reduce the width of the health bar's inner rectangle by 1 pixel\n    healthBar.outer.width -= 5;\n  } else {\n    // Make the explorer fully opaque (non-transparent) if it hasn't been hit\n    explorer.alpha = 1;\n  }\n\n  // Check for a collision between the explorer and the treasure\n  if (bump.hitTestRectangle(explorer, treasure)) {\n    // If the treasure is touching the explorer, center it over the explorer\n    treasure.x = explorer.x + 8;\n    treasure.y = explorer.y + 8;\n  }\n\n  // Does the explorer have enough health? If the width of the `innerBar`\n  // is less than zero, end the game and display \"You lost!\"\n  if (healthBar.outer.width <= 0) {\n    state = end;\n    message.text = \"You lost!\";\n  }\n\n  // If the explorer has brought the treasure to the exit,\n  // end the game and display \"You won!\"\n  if (bump.hitTestRectangle(treasure, door)) {\n    state = end;\n    message.text = \"You won!\";\n  }\n}\n\nfunction end() {\n  gameScene.visible = false;\n  gameOverScene.visible = true;\n}\n\nfunction initHealthBar() {\n  // Create the health bar\n  var healthBar = new Container();\n\n  // Create the black background rectangle\n  var innerBar = new Graphics();\n  innerBar.beginFill(0);\n  innerBar.drawRect(0, 0, 128, 8);\n  innerBar.endFill();\n  healthBar.addChild(innerBar);\n\n  // Create the front red rectangle\n  var outerBar = new Graphics();\n  outerBar.beginFill(16724736);\n  outerBar.drawRect(0, 0, 128, 8);\n  outerBar.endFill();\n  healthBar.addChild(outerBar);\n\n  healthBar.outer = outerBar;\n\n  return healthBar;\n}\n\nfunction bindKeyBorad() {\n  // Capture the keyboard arrow keys\n  var left = keyboard(37);\n  var right = keyboard(39);\n  var up = keyboard(38);\n  var down = keyboard(40);\n\n  // Left arrow key 'press' method\n  left.press = function () {\n    // Change the explorer's velocity when the key is pressed\n    explorer.vx = -explorerSpeed;\n    explorer.vy = 0;\n  };\n\n  // Left arrow key 'elease' method\n  left.release = function () {\n    // If the left arrow has been released, and the right arrow isn't down,\n    // and the explorer isn't moving vertically, stop the sprite from moving\n    // by setting its velocity to zero\n    if (!right.isDown && explorer.vy === 0) {\n      explorer.vx = 0;\n    }\n  };\n\n  //Right\n  right.press = function () {\n    explorer.vx = explorerSpeed;\n    explorer.vy = 0;\n  };\n\n  right.release = function () {\n    if (!left.isDown && explorer.vy === 0) {\n      explorer.vx = 0;\n    }\n  };\n\n  // Up\n  up.press = function () {\n    explorer.vy = -explorerSpeed;\n    explorer.vx = 0;\n  };\n\n  up.release = function () {\n    if (!down.isDown && explorer.vx === 0) {\n      explorer.vy = 0;\n    }\n  };\n\n  // Down\n  down.press = function () {\n    explorer.vy = explorerSpeed;\n    explorer.vx = 0;\n  };\n\n  down.release = function () {\n    if (!up.isDown && explorer.vx === 0) {\n      explorer.vy = 0;\n    }\n  };\n}\n\n// The game's helper functions:\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction linkFont(source) {\n  // console.log(\"linkFont\", source)\n  // Use the font's filename as the 'fontFamily' name.\n  // This code captures the font file's name without the extension or file path\n  var fontFamily = source.split(\"/\").pop().split(\".\")[0];\n\n  // Append an '@font-face' style rule to the head of the HTML document\n  var newStyle = document.createElement(\"style\");\n  var fontFace = \"@font-face {\\n    font-family: \\\"\" + fontFamily + \"\\\";\\n    src: url(\\\"\" + source + \"\\\");\\n  }\";\n  newStyle.appendChild(document.createTextNode(fontFace));\n  document.head.appendChild(newStyle);\n}\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// chapter_04/treasure-hunter/main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 32dd76c64819d070ad88","/**\n * @fileoverview Treasure Hunter\n * @author burning <iburning@live.cn>\n * @version 2017.08.28\n */\n\n//Aliases\n// console.log('PIXI', PIXI)\nconst Container = PIXI.Container\nconst Graphics = PIXI.Graphics\nconst Loader = PIXI.loader\nconst Rectangle = PIXI.Rectangle\nconst Renderer = PIXI.autoDetectRenderer\nconst Resources = PIXI.loader.resources\nconst Sprite = PIXI.Sprite\nconst Text = PIXI.Text\nconst TextureCache = PIXI.utils.TextureCache\nconst Texture = PIXI.Texture\n\n// Create a new instance of the Bump collision library\nconst bump = new Bump(PIXI)\n\n// Create a Pixi renderer\nconst renderer = Renderer(512, 512)\n// Set the canvas's border style and background color\nrenderer.view.style.border = \"1px solid #000\"\nrenderer.backgroundColor = \"0xFFFFFF\"\n\n// Add the canvas to the HTML document\ndocument.getElementById(\"pixi\").appendChild(renderer.view)\n\n// Create a container object called the 'stage'\nconst stage = new Container()\n\nlet gameScene = null\nlet gameOverScene = null\n\n// Set the initial game state\nlet state = play\nlet explorer = null\nlet explorerSpeed = 3\n// An array to store all the blob monsters\nlet blobs = []\nlet blobSpeed = 5\nlet treasure = null\nlet door = null\nlet healthBar = null\nlet message = null\n\nlinkFont(\"assets/Pixilator.ttf\")\n\n// Load resources (images and fonts) and run the 'setup' function when it's done\nLoader.add([\n  \"assets/treasureHunter.json\",\n  \"assets/Pixilator.ttf\"\n]).load(setup)\n\n\nfunction setup() {\n  // Create an 'id' alias for the texture atlas frame ids\n  id = Resources[\"assets/treasureHunter.json\"].textures\n  // console.log('id', id)\n\n  // The 'gameScene' container that contains all the main game sprites\n  gameScene = new Container()\n  stage.addChild(gameScene)\n\n  // Create the main sprites:\n  // The 'dungeon' sprite\n  let dungeon = new Sprite(id['dungeon.png'])\n  gameScene.addChild(dungeon)\n\n  // The 'door' sprite\n  door = new Sprite(id['door.png'])\n  door.position.set(32, 0)\n  gameScene.addChild(door)\n\n  // The 'explorer' sprite\n  explorer = new Sprite(id['explorer.png'])\n  explorer.x = 64\n  explorer.y = (gameScene.height - explorer.height) / 2\n  explorer.vx = 0\n  explorer.vy = 0\n  gameScene.addChild(explorer)\n\n  // The 'treasure' sprite\n  treasure = new Sprite(id['treasure.png'])\n  treasure.x = gameScene.width - treasure.height - 48\n  treasure.y = (gameScene.height - treasure.height) / 2\n  gameScene.addChild(treasure)\n\n  // The 'blobs' enemy sprites\n  let numberOfBlobs = 6\n  let spacing = 48\n  let xOffset = 150\n  let direction = 1\n\n  // Make as many blobs as there are 'numberOfBlobs'\n  for (let i = 0; i < numberOfBlobs; i++) {\n    // Make a blob\n    let blob = new Sprite(id[\"blob.png\"])\n\n    // Space each blob horizontally according to the 'spacing' value.\n    // 'xOffset' determines the point from the left of the screen\n    // at which the first blob should be added\n    let x = spacing * i + xOffset\n\n    // Give the blob a random y position\n    let y = randomInt(0, stage.height - blob.height)\n\n    // Set the blob's position\n    blob.x = x\n    blob.y = y\n\n    // Set the blob's vertical velocity. 'direction' will be either '1' or '-1'.\n    // '1' means enemy will move down and '-1' means the blob will move up.\n    // Multiplying 'direction' by 'speed' determines the blob's vertical direction\n    blob.vy = blobSpeed * direction\n\n    // Reverse the direction for the next blob\n    direction *= -1\n\n    // Push the blob into the 'blobs' array\n    blobs.push(blob)\n    // Add the blob to the 'gameScene'\n    gameScene.addChild(blob)\n  }\n\n  healthBar = initHealthBar()\n  healthBar.position.set(stage.width - 170, 4)\n  gameScene.addChild(healthBar)\n\n  // Create the 'gameOver' scene\n  gameOverScene = new Container()\n  stage.addChild(gameOverScene)\n  // Make the 'gameOver' scene invisible when the game first starts\n  gameOverScene.visible = false\n\n  // Create the text sprite and add it to the 'gameOver' scene\n  message = new Text(\"The End!\", { font: \"48px Pixilator\" })\n  message.x = (stage.width - message.width) / 2\n  message.y = stage.height / 2 - 32\n  gameOverScene.addChild(message)\n\n  // Bind keyboard\n  bindKeyBorad()\n\n  // Set the game's current state to 'play'\n  state = play\n\n  // Start the game loop\n  gameLoop()\n}\n\n\nfunction gameLoop() {\n  // Loop this function 60 times per second\n  requestAnimationFrame(gameLoop)\n\n  // Run the current state\n  state()\n\n  // Render the stage\n  renderer.render(stage)\n}\n\n\nfunction play() {\n  // All the game logic goes here\n\n  let area = { x: 28, y: 10, width: 488, height: 480 }\n\n  // Use the explorer's velocity to make it move\n  explorer.x += explorer.vx\n  explorer.y += explorer.vy\n\n  // Contain the explorer inside the area of the dungeon\n  bump.contain(explorer, area)\n\n  // Set 'explorerHit' to 'false' before checking for a collision\n  var explorerHit = false\n\n  // Loop through all the sprites in the 'enemies' array\n  blobs.forEach(blob => {\n    // Move the blob\n    blob.y += blob.vy\n\n    // Check the blob's screen boundaries\n    let blobHitsWall = bump.contain(blob, area)\n\n    // If the blob hits the top or bottom of the stage,\n    // reverse its direction\n    if (blobHitsWall) {\n      if (blobHitsWall.has(\"top\") || blobHitsWall.has(\"bottom\")) {\n        blob.vy *= -1\n      }\n    }\n\n    // Test for a collision. If any of the enemies are touching the explorer,\n    // set 'explorerHit' to 'true'\n    if (bump.hitTestRectangle(explorer, blob)) {\n      explorerHit = true\n    }\n  })\n\n  // If the explorer is hit...\n  if (explorerHit) {\n    // Make the explorer semi-transparent\n    explorer.alpha = 0.5\n\n    // Reduce the width of the health bar's inner rectangle by 1 pixel\n    healthBar.outer.width -= 5\n  }\n  else {\n    // Make the explorer fully opaque (non-transparent) if it hasn't been hit\n    explorer.alpha = 1\n  }\n\n\n  // Check for a collision between the explorer and the treasure\n  if (bump.hitTestRectangle(explorer, treasure)) {\n    // If the treasure is touching the explorer, center it over the explorer\n    treasure.x = explorer.x + 8\n    treasure.y = explorer.y + 8\n  }\n\n  // Does the explorer have enough health? If the width of the `innerBar`\n  // is less than zero, end the game and display \"You lost!\"\n  if (healthBar.outer.width <= 0) {\n    state = end\n    message.text = \"You lost!\"\n  }\n\n  // If the explorer has brought the treasure to the exit,\n  // end the game and display \"You won!\"\n  if (bump.hitTestRectangle(treasure, door)) {\n    state = end\n    message.text = \"You won!\";\n  }\n}\n\n\nfunction end() {\n  gameScene.visible = false\n  gameOverScene.visible = true\n}\n\nfunction initHealthBar() {\n  // Create the health bar\n  let healthBar = new Container()\n\n  // Create the black background rectangle\n  let innerBar = new Graphics()\n  innerBar.beginFill(0)\n  innerBar.drawRect(0, 0, 128, 8)\n  innerBar.endFill()\n  healthBar.addChild(innerBar)\n\n  // Create the front red rectangle\n  let outerBar = new Graphics()\n  outerBar.beginFill(16724736)\n  outerBar.drawRect(0, 0, 128, 8)\n  outerBar.endFill()\n  healthBar.addChild(outerBar)\n\n  healthBar.outer = outerBar\n\n  return healthBar\n}\n\n\nfunction bindKeyBorad() {\n  // Capture the keyboard arrow keys\n  let left = keyboard(37)\n  let right = keyboard(39)\n  let up = keyboard(38)\n  let down = keyboard(40)\n\n  // Left arrow key 'press' method\n  left.press = function () {\n    // Change the explorer's velocity when the key is pressed\n    explorer.vx = -explorerSpeed\n    explorer.vy = 0\n  }\n\n  // Left arrow key 'elease' method\n  left.release = function () {\n    // If the left arrow has been released, and the right arrow isn't down,\n    // and the explorer isn't moving vertically, stop the sprite from moving\n    // by setting its velocity to zero\n    if (!right.isDown && explorer.vy === 0) {\n      explorer.vx = 0\n    }\n  }\n\n  //Right\n  right.press = function () {\n    explorer.vx = explorerSpeed\n    explorer.vy = 0\n  }\n\n  right.release = function () {\n    if (!left.isDown && explorer.vy === 0) {\n      explorer.vx = 0\n    }\n  }\n\n  // Up\n  up.press = function () {\n    explorer.vy = -explorerSpeed\n    explorer.vx = 0\n  }\n\n  up.release = function () {\n    if (!down.isDown && explorer.vx === 0) {\n      explorer.vy = 0\n    }\n  }\n\n  // Down\n  down.press = function () {\n    explorer.vy = explorerSpeed\n    explorer.vx = 0\n  }\n\n  down.release = function () {\n    if (!up.isDown && explorer.vx === 0) {\n      explorer.vy = 0\n    }\n  }\n}\n\n\n// The game's helper functions:\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\n\nfunction linkFont(source) {\n  // console.log(\"linkFont\", source)\n  // Use the font's filename as the 'fontFamily' name.\n  // This code captures the font file's name without the extension or file path\n  let fontFamily = source.split(\"/\").pop().split(\".\")[0]\n\n  // Append an '@font-face' style rule to the head of the HTML document\n  let newStyle = document.createElement(\"style\")\n  let fontFace = `@font-face {\n    font-family: \"${fontFamily}\";\n    src: url(\"${source}\");\n  }`\n  newStyle.appendChild(document.createTextNode(fontFace))\n  document.head.appendChild(newStyle)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/chapter_04/treasure-hunter.js"],"sourceRoot":""}